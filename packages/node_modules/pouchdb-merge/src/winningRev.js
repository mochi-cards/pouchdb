// We fetch all leafs of the revision tree, and sort them based on tree length
// and whether they were deleted, undeleted documents with the longest revision
// tree (most edits) win
// The final sort algorithm is slightly documented in a sidebar here:
// UPDATE: We are removing the deleted check here because it breaks calls to
// bulkDocs with new_edits: false. It breaks because the winningRev function
// will always choose the non-deleted leaf revision (ie whatever revision is
// the current revision on the doc). The reason this works with pouchdb's
// replication is because pouchdb fetches and merges the entire revision history
// from remote. I have also not found any evidence that CouchDB prioritizes
// non-deleted leaf revisions.
// http://guide.couchdb.org/draft/conflicts.html
function winningRev(metadata) {
  var winningId;
  var winningPos;
  var toVisit = metadata.rev_tree.slice();
  var node;
  while ((node = toVisit.pop())) {
    var tree = node.ids;
    var branches = tree[2];
    var pos = node.pos;
    if (branches.length) { // non-leaf
      for (var i = 0, len = branches.length; i < len; i++) {
        toVisit.push({pos: pos + 1, ids: branches[i]});
      }
      continue;
    }
    var id = tree[0];
    // sort by pos, then id
    if (!winningId || (winningPos !== pos ? winningPos < pos : winningId < id)) {
      winningId = id;
      winningPos = pos;
    }
  }

  return winningPos + '-' + winningId;
}

export default winningRev;
